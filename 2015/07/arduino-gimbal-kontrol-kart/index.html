<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=description content="An example site for the clean and configurable Hugo Classless theme."><link href=/2015/07/arduino-gimbal-kontrol-kart/ rel=alternate type=application/rss+xml title=mozanunal.com><link id=theme-style rel=stylesheet href=/css/classless.20c8e211f6768ba295effc3e101a31bfe248db7295bb122355bdf893c6cee731.css integrity="sha256-IMjiEfZ2i6KV7/w+EBoxv+JI23KVuxIjVb34k8bO5zE="><style>pre code,code{-webkit-text-size-adjust:100%;text-size-adjust:100%}pre code.hljs{all:revert;display:block;overflow-x:auto}img{display:block;margin-left:auto;margin-right:auto}figcaption{display:block;margin-left:auto;margin-right:auto}</style><title>[TR] Arduino Gimbal Kontrol Kartı | mozanunal.com</title><link rel=icon href=/favicon.svg type=image/svg+xml><link rel="shortcut icon" href=/favicon.ico><link rel=apple-touch-icon href=/apple-touch-icon.png></head><body><header><div><h1>mozanunal.com</h1><nav><p><a href=/>Home</a> | <a href=/posts/>Posts</a> | <a href=/projects/>Projects</a> | <a href=/papers/>Papers</a> | <a href=/contact/>Contact</a></p></nav></div></header><main><article><header><h1>[TR] Arduino Gimbal Kontrol Kartı</h1><p><em><time datetime=2015-07-04>July 4, 2015</time></em></p></header><div><p><strong>Herkese Merhabalar,</strong></p><p>Daha önce kolay bulunabilecek malzemelerden nasıl gimbal yapılabileceğinden
bahsetmiştim
(<a href=https://mozanunal.com/2015/06/2-eksenli-servo-gimbal-yapm/>O yazıya buradan ulaşabiliriniz</a>).
Kontrol kartını sonra anlatacağım demiştim. Veee bu yazımda arduino ve MPU6050
sensörü kullanarak nasıl bir gimbal kontrol kartı yapabileceğimizden
bahsedeceğim. Bu kart sayesinde gimbalin yere göre açısını kontrol edebileceğiz.
Yere göre açısının sabit kalmasını da kontrol kartı üzerindeki IMU sensörü ile
sağlayacağız(<a href=https://mozanunal.com/2014/11/imu-aclarnn-3-boyutlu-olarak/>Ayrıntılı bilgi için tıklayınız</a>).
Kontrol kartı saniyede 100 değer okuyup servo PWM değerlerini ona göre
güncelliyor. Bu sayede oldukça yüksek çözünürlüklü her türlü seviyede
kullanılabilecek bir kontrol kartı yapmış oluyoruz. Ayrıca başa koyduğum ayar
parametreleri sayesinde her boyutta ve çeşitte servo gimbale kolayca uyumlu hale
getirilebilir. Kontrol kartının tanıtım videosu aşağıdadır.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/MnfJcTREYPo?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>Bağlantılara gelecek olursak MPU6050 I2C pinlerinden arduinoya bağlanıyor. Gnd
pini gndye, Vcc pini ise 3.3 volta bağlanıyor. Çalışma voltajı 3.3 volt olduğu
için. Servoların sinyal pinlerini ayarlardan seçtiğimiz dijital pinlere
bağlıyoruz. Servoların beslemesi eğer küçük servolar ise arduino üzerinden eğer
yüksek akım çeken servolarsa harici olarak yapabilirsiniz. Fakat harici besleme
yaparsanız arduino ve güç kaynağının topraklarını eşitlemeyi unutmayın.</p><pre><code class=language-cpp>////////////////////Ayarlar////////////////  
//pitch  
int p_pin=8;  
int p_neturalpos=90;  
int p_gain=1;  
int p_min=30;  
int p_max=150;  
int p_reverse=0;  
//roll  
int r_pin=9;  
int r_neturalpos=90;  
int r_gain=1;  
int r_min=30;  
int r_max=150;  
int r_reverse=0;  

///////////////////////////////////////////////
</code></pre><p>Bunlar, koddaki ayar parametreleri, çeşitli gimballere kolay adapte edilebilmesi
içindir. İlk pozisyonunu, en düşük, en yüksek servo açılarını, kazancını bu
parametrelerle kontrol edeceğiz. Kazanç ise kontrol kartındaki açı
değişimlerinin servoya kaçla çarpılarak yansıtılacağının
parametresidir.&ldquo;Reverse&rdquo; değişkeni &ldquo;1&rdquo; veya &ldquo;0&rdquo; yapılarak yönün ters çevirilmesi
sağlanabilir. Benim gimbalim için &ldquo;Pitch&rdquo; eksenini ters yapmam gerekmişti.</p><p><strong>Sistemin Fotoğrafları</strong></p><p><img src=IMG_20150703_170713.jpg alt></p><p><img src=IMG_20150703_170813.jpg alt></p><p><strong>Projenin full kaynak kodu:</strong></p><pre><code class=language-cpp>#include &lt;I2Cdev.h&gt;  
#include &lt;MPU60X0.h&gt;  
#include &lt;EEPROM.h&gt;  
#include &quot;DebugUtils.h&quot;  
#include &quot;CommunicationUtils.h&quot;  
#include &quot;FreeIMU.h&quot;  
#include &lt;Wire.h&gt;  
#include &lt;SPI.h&gt;  
#include &lt;Servo.h&gt;  
////////////////////Ayarlar////////////////  
//pitch  
int p_pin=8;  
int p_neturalpos=90;  
int p_gain=1;  
int p_min=30;  
int p_max=150;  
int p_reverse=0;  
//roll  
int r_pin=9;  
int r_neturalpos=90;  
int r_gain=1;  
int r_min=30;  
int r_max=150;  
int r_reverse=0;  

///////////////////////////////////////////////  
Servo pitchservo;  
Servo rollservo;  
int p_angle=90;  
int r_angle=90;  
int raw_values[9];  
float ypr[3]; // yaw pitch roll  
float val[9];  

FreeIMU my3IMU = FreeIMU();  

void setup() {  
  Serial.begin(115200);  
  pitchservo.attach(p_pin);  
  rollservo.attach(r_pin);  
  Wire.begin();  
  delay(5);  
  my3IMU.init();  
  delay(5);  
}  

void loop() {  

  my3IMU.getYawPitchRoll(ypr);  
  Serial.print(&quot;Yaw: &quot;);  
  Serial.print(ypr[0]);  
  Serial.print(&quot; Pitch: &quot;);  
  Serial.print(ypr[1]);  
  Serial.print(&quot; Roll: &quot;);  
  Serial.print(ypr[2]);  
  Serial.println(&quot;&quot;);  

  p_angle=p_neturalpos+ypr[1]*p_gain;  
  if(p_angle&gt;p_max){  
    p_angle=p_max;  
  }  
  if(p_angle&lt;p_min){  
    p_angle=p_min;  
  }  
  if(p_reverse=1){  
    p_angle=180-p_angle;  
  }  
  pitchservo.write(p_angle);  

  r_angle=r_neturalpos+ypr[2]*r_gain;  
  if(r_angle&gt;r_max){  
    r_angle=r_max;  
  }  
  if(r_angle&lt;r_min){  
    r_angle=r_min;  
  }  
  if(r_reverse=1){  
    r_angle=180-r_angle;  
  }  
  rollservo.write(r_angle);  

  delay(10);  
}
</code></pre></div></article></main><footer><p>&copy; 2025 M.Ozan Unal.</p></footer></body><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/highlight.js@11.11.0/styles/github.min.css media="(prefers-color-scheme: light)"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/highlight.js@11.11.0/styles/github-dark.min.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js></script><script>hljs.highlightAll()</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\\\[",right:"\\\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\\\(",right:"\\\\)",display:!1}],throwOnError:!1})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-007KSW65JL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-007KSW65JL")}</script></html>