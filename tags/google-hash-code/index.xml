<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Google Hash Code on mozanunal.com</title>
    <link>https://mozanunal.com/tags/google-hash-code/</link>
    <description>Recent content in Google Hash Code on mozanunal.com</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 31 Mar 2020 23:00:12 +0000</lastBuildDate>
    <atom:link href="https://mozanunal.com/tags/google-hash-code/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hash Code 2020</title>
      <link>https://mozanunal.com/2020/03/hash-code-2020/</link>
      <pubDate>Tue, 31 Mar 2020 23:00:12 +0000</pubDate>
      <guid>https://mozanunal.com/2020/03/hash-code-2020/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Hello Everyone,&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;I want to share our solution for Google Hash Code 2020. It is the code repo of&#xA;team titanium-white for Google Hash Code 2020 Online Qualification Round. We&#xA;have writen our code in Python.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mozanunal/hashcode2020&#34;&gt;Code can be reached from here&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;&#xA;&lt;p&gt;Basically, the problem class is the backbone of the system.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;It handles the inputs and outputs with functions &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;dump&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;It read the input files and creates objects according to that. I think the one&#xA;of the thing we did well is this &lt;code&gt;__init__&lt;/code&gt; function. It create all the&#xA;objects like books, libraries even if book2score dictionary.&lt;/li&gt;&#xA;&lt;li&gt;It also handles the solving opeartion. It iterate trough the days and get max&#xA;predicted score from every library available. When the libraries calculating&#xA;the max pred scores, they get the current state as input. Therefore their&#xA;predictionsa are more accurate. After the library is selected the state is&#xA;updated such as day, already scanned books and state of the selected library.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# main.py&#xA;from library import Library, Book&#xA;import numpy as np&#xA;&#xA;class Problem(object):&#xA;    def __init__(self, filename):&#xA;        print(&#39;file--&#39;, filename)&#xA;        f = open(filename)&#xA;        l = f.readline().split(&#39; &#39;)&#xA;        self.filename = filename&#xA;        self.nBooks, self.nLibs, self.nDays = int(l[0]), int(l[1]), int(l[2])&#xA;        self.books = [ Book(i,int(score)) for i, score in enumerate(f.readline().split(&#39; &#39;))]&#xA;        sumb = 0&#xA;        for b in self.books:&#xA;            sumb += b.score&#xA;        print( sumb/1000000 )&#xA;        self.book2Score = {book.id: int(book.score) for book in self.books}&#xA;        self.libs = []&#xA;        for libId in range(self.nLibs):&#xA;            l = [int(i) for i in f.readline().split(&#39; &#39;)]&#xA;            nBooks, nSign, nScan = l[0], l[1], l[2]&#xA;            books = [ Book(int(i), int(self.book2Score[int(i)])) for i in f.readline().split(&#39; &#39;) ] &#xA;            lib = Library(libId, nBooks, nSign, nScan, books)&#xA;            self.libs.append(lib) &#xA;        self.pri()&#xA;&#xA;    def solve(self):&#xA;        t = 0&#xA;        solution = []&#xA;        readBookSet  = set()&#xA;        while t &amp;lt; self.nDays:&#xA;            print(&#39;-----&#39;, t)&#xA;            scoreList = []&#xA;            readBookList = []&#xA;            for lib in self.libs:&#xA;                if lib.registered == False:&#xA;                    score, curBookList = lib.predMaxScore(self.nDays - t, readBookSet)&#xA;                    scoreList.append( score )&#xA;                    readBookList.append( curBookList )&#xA;                else:&#xA;                    scoreList.append(0)&#xA;                    readBookList.append( [ ] )&#xA;            if len(scoreList) == 0:&#xA;                break&#xA;            if max(scoreList) == 0:&#xA;                break&#xA;            libIndex = scoreList.index(max(scoreList))&#xA;            self.libs[libIndex].registeredDay = t&#xA;            self.libs[libIndex].registered = True&#xA;            self.libs[libIndex].solBooks = readBookList[libIndex]&#xA;            readBookSet = readBookSet.union(readBookList[libIndex])&#xA;            solution.append(self.libs[libIndex])&#xA;            t += self.libs[libIndex].nSign&#xA;        print([(lib.id, lib.nSign, lib.registeredDay) for lib in solution])&#xA;        return solution&#xA;&#xA;    def dump(self, solution):&#xA;        f = open(self.filename.replace(&#39;data/&#39;, &#39;out/&#39;), &#39;w+&#39;)&#xA;        f.write(&#39;{}\n&#39;.format(len(solution)))&#xA;        for lib in solution:&#xA;            books = lib.solBooks&#xA;            f.write(&#39;{} {}\n&#39;.format(&#xA;                lib.id, len(books)&#xA;            ))&#xA;            s = &amp;quot;&amp;quot;&#xA;            for book in books:&#xA;                s+= str(book) + &#39; &#39;&#xA;            s+=&#39;\n&#39;&#xA;            f.write(s)&#xA;        f.close()&#xA;&#xA;&#xA;&#xA;    def pri(self):&#xA;        print(&#39;------&#39;)&#xA;        print(self.nBooks, self.nLibs, self.nDays)&#xA;        #print(self.libs)&#xA;        print(&#39;------&#39;)&#xA;&#xA;&#xA;if __name__ == &amp;quot;__main__&amp;quot;:&#xA;    p = Problem(&#39;data/a.txt&#39;)&#xA;    solution = p.solve()&#xA;    p.dump(solution)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The Second critical class is &lt;code&gt;Library&lt;/code&gt; class. The vital function in our&#xA;implementation is predMaxScore. We are doing calculating this with&#xA;&lt;code&gt;total book score / (sign day*sign day)&lt;/code&gt;. Because, during our experiments, we&#xA;saw that the sign days length is quite important especially for some datasets.&#xA;Total book score is simply if in that day the library is chosen, how much of the&#xA;books can be scanned until the end of total days. Of course these books are&#xA;selecting according to their scores and they should be not scanned before.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
